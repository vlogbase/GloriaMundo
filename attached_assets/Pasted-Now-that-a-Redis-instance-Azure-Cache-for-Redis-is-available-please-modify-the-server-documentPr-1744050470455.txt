Now that a Redis instance (Azure Cache for Redis) is available, please modify the `server/documentProcessor.ts` file again to replace the use of `setTimeout` for background document processing with a BullMQ job queue.

1.  **Import BullMQ & Redis Client:** Ensure `Queue`, `Worker` from `bullmq` and `Redis` from `ioredis` (or your preferred Redis client library) are imported at the top of the file.
2.  **Get Redis Connection Details:**
    * **Ask the user** to provide the connection details for the Azure Cache for Redis instance. Specifically, request the **host**, **port**, and **password**.
    * Wait for the user to provide these three values.
3.  **Configure Redis Connection Object:** Once the user provides the host, port, and password, create a Redis connection options object using these values. Parse the port to ensure it's a number.
    ```typescript
    // Example structure - use the values provided by the user
    const redisConnectionOptions = {
      host: /* user_provided_host */,
      port: parseInt(/* user_provided_port */, 10),
      password: /* user_provided_password */,
      // Add other options like maxRetriesPerRequest: null if needed for Azure Redis
       enableReadyCheck: false, // Often recommended for some cloud providers
       maxRetriesPerRequest: null
     };
    ```
4.  **Initialize Queue:** Define a BullMQ queue instance using the `redisConnectionOptions` object created above (e.g., `const documentProcessingQueue = new Queue('document-processing', { connection: redisConnectionOptions });`).
5.  **Enqueue Job:** Locate the `processDocument` function. Find where the `setTimeout` call *was* (or where background processing should start - likely after the initial document record is created). Add a job to the `documentProcessingQueue` using `.add()`. Pass necessary data in the job payload (e.g., `{ documentId: document.id, text: text, fileName: fileName }`).
6.  **Create Worker:** Define a BullMQ worker instance that processes jobs from the `document-processing` queue, also using the `redisConnectionOptions` object (e.g., `const documentProcessingWorker = new Worker('document-processing', async (job) => { ... }, { connection: redisConnectionOptions });`).
7.  **Move Logic to Worker:** Move the code previously intended for the `setTimeout` callback (the asynchronous logic performing chunking, embedding generation, and updating chunk storage) into the worker's job processing function (`async (job) => { ... }`). Access the needed data (like `documentId`, `text`) from `job.data`.
8.  **Worker Event Handling:** Add basic event handlers to the worker for `'completed'` and `'failed'` jobs to log success or errors using `console.log`/`console.error`. Ensure errors within the job processing function are caught.
9.  **Remove `setTimeout`:** Double-check that no `setTimeout` logic for background document processing remains. Remove any fallback logic that was added previously to handle the *absence* of Redis.